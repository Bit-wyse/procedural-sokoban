<h1>Master Puzzle Listing</h1>

<%= link_to 'New puzzle', new_puzzle_path %>

<script type="text/javascript">

  var emptyID = 0;
  var obstacleID = 9;
  var boxID = emptyID + 1;
  var goalID = 3;

  class TNode {
    constructor(state, parent = null, children = [], q = 0, n = 0,
        visited = false, exhausted = false, root = false) {
      this.state = state;
      this.parent = parent;
      this.children = children;
      this.root = root;
      this.q = q;
      this.n = n;
      this.visited = visited;
      this.exhaused = exhausted;
    }

    isRoot() {
      if (typeof(this.parent) === "object") {
        return false;
      } else {
        return true;
      }
    }
  }

  function mctsInit(m, n) { // creates root (m by n) filled with obstacles
    var state = Array.from({ length: n},
      () => Array.from({length: m}, () => obstacleID));
    state[Math.trunc(state.length / 2)][Math.trunc(state[0].length / 2)]
      = emptyID + 2;

    return new TNode(state, root = true);
  }

  function mctsMain(root) {
    var score = 0;
    var leaf = null;
    while (score < 0.2) {
      leaf = mctsTrav(root)
      score = mctsEval(leaf); // is this right?
      mctsProp(leaf, score);
    }
    return [leaf, score]; // still need to figure out when it freezes level
  }

  function mctsTrav(node) { // FIX store uct evaluation on node object for speed
    var nodeCurrent = node
    while (nodeCurrent.exhausted) {
      var bestUCT = 0;
      var nodeNext = null;
      for (i = 0; i < nodeCurrent.children.length; i++) {
        var uct = mctsUCT(nodeCurrent.children[i]);
        if (uct >= bestUCT) {
          bestUCT = uct;
          nodeNext = nodeCurrent.children[i];
        }
      }
      nodeCurrent = nodeNext;
    }
    if (nodeCurrent.children.length == 0) {
      return null
    } else {

    }
  }

  function mctsBest(node) { // choose best child (num times propagated thru)
    var best = [null, 0];
    for (i = 0; i < node.children.length; i++) {
      maxer = node.children[i].n;
      if (maxer >= best[1]) {
        best = [node.children[i], maxer];
      }
    }

    return best[0];
  }

  function mctsRoll(node) { // rollout policy, NOT FULL ROLLOUT
    roll = Math.random();
    numCh = node.children.length;
    for (i = 0; i < numCh; i++) {
      if (roll < (i + 1) / numCh) {
        return node.children[i];
      }
    }
    return null;
  }

  function mctsProp(node, result) { // recursively backpropagate to origin node
    if (node.isRoot()) {
      return;
    }
    node.q += result;
    node.n += 1;
    mctsProp(node.parent, result);
  }

  function mctsEval(node) { // equation 2 from paper
    var terrain = 0;
    var congestion = 0;

    var neighbors = [0, 0, 0, 0];

    // constant parameters
    var a = 4;
    var b = 4;
    var c = 1;
    var k = 200;

    var boxes = [];
    var goalsUnordered = [];

    for (i = 0; i < node.state.length; i++) {
      for (j = 0; j < node.state[i].length; j++) {
        if (node.state[i][j] == emptyID || node.state[i][j] == emptyID + 1 ||
            node.state[i][j] == emptyID + 2) {
          neighbors = [j+1, i+1, j-1, i-1]; // right, up, left, down

          if (neighbors[0] < node.state[i].length) {
            if (node.state[i][neighbors[0]] == obstacleID) {
              terrain++;
            }
          }

          if (neighbors[1] < node.state.length) {
            if (node.state[neighbors[1]][j] == obstacleID) {
              terrain++;
            }
          }

          if (neighbors[2] >= 0) {
            if (node.state[i][neighbors[2]] == obstacleID) {
              terrain++;
            }
          }

          if (neighbors[3] >= 0) {
            if (node.state[neighbors[3]][j] == obstacleID) {
              terrain++;
            }
          }

        }

        if (node.state[i][j] == boxID) {
          boxes.push([i, j]);
        }

        if (node.state[i][j] == goalID) {
          goalsUnordered.push([i, j]);
        }

      }
    }

    var goals = [];
    for (box = 0; box < boxes.length; box++) {
      var shortest = [Number.POSITIVE_INFINITY, goalsUnordered[box]];
      for (goal = 0; goal < goalsUnordered.length; goal++) {
        var dist = Math.sqrt((boxes[box][0] - goalsUnordered[goal][0])**2
          + (boxes[box][1] - goalsUnordered[goal][1])**2);
        if (dist < shortest[0]) {
          shortest[0] = dist;
          shortest[1] = goal; // index in the goalsUnordered array
        }

      }
      goals.push(goalsUnordered[shortest[1]]); // reorder corresponding to boxes
      goalsUnordered.splice(shortest[1], 1);
    }
    for (box = 0; box < boxes.length; box++) {
      for (i = Math.min(boxes[box][0], goals[box][0]); i <= Math.max(boxes[box][0], goals[box][0]); i++) {
        for (j = Math.min(boxes[box][1], goals[box][1]); j <= Math.max(boxes[box][1], goals[box][1]); j++) {
          if (node.state[i][j] == boxID) {
            congestion += a;
          }
          if (node.state[i][j] == goalID) {
            congestion += b;
          }
          if (node.state[i][j] == obstacleID) {
            congestion += c;
          }
          console.log(box, congestion);
        }
      }
    }
    console.log(terrain);
    console.log(congestion);
    return (Math.sqrt(terrain * congestion)) / k;
  }


  function mctsUCT(node) { // equation 1 from paper
    var w;
    var pi_s;
    var c = Math.sqrt(2);
    var p_v;
    var s_v;

    return w * pi_s + c * Math.sqrt(Math.log(p_v)/s_v);
  }

  // Testing
  //var root = new TNode(state=[ [9,9,9,9,9], [0,0,0,0,3], [0,1,2,0,9], [9,1,1,0,3], [3,0,1,0,3] ], root=true);
  //console.log(mctsEval(root));


</script>

<table>
  <tr>
    <th>Name</th>
    <th>Game</th>
    <th></th>
  </tr>

  <% @puzzles.each do |puzzle| %>
    <tr>
      <td><%= puzzle.name %></td>
      <td><%= puzzle.game %></td>
      <td><%= link_to 'Show', puzzle_path(puzzle) %></td>
      <td><%= link_to 'Edit', edit_puzzle_path(puzzle) %></td>
      <td><%= link_to 'Remove', puzzle_path(puzzle),
              method: :delete,
              data: { confirm: 'Are you sure?' } %></td>
    </tr>
  <% end %>
</table>
